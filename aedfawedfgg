#define _CRT_SECURE_NO_WARNINGS

#include<iostream>

#include<queue>

#include<cstring>

#include <algorithm>

#include <stdio.h>

 

using namespace std;

int map[8][8];

int check[100][100];

int dx[4] = { 0,0,-1,1 };

int dy[4] = { -1,1,0,0 };

int n,m,ret;

int a[10000];

int c[100];

vector<int> v;

void bfs() {

	queue<int> q;

	int backup[8][8];

	int visited[8][8] = { 0, };

	for (int y = 0; y < n; ++y) {

 

		for (int x = 0; x < m; ++x) {

			backup[y][x] = map[y][x];// 맵좌표를 백업좌표에 업데이트

			if (backup[y][x] == 2) {//유해가스가 있으면

				q.push(y * 10 + x);//x,y값이 하나의 인티저 값으로 복원된다.

				visited[y][x] = 1;

 

			}

		}

	}

	while (!q.empty()) {

		int cur = q.front();

		q.pop();

		int cy = cur / 10;

		int cx = cur % 10;

		backup[cy][cx] = 2;

		for (int dir = 0; dir < 4; dir++) {

			int ny = cy + dy[dir];

			int nx = cx + dx[dir];

 

			if (ny < 0 || ny >= n || nx < 0 || nx >= m) {

				continue;

			}

			if (visited[ny][nx] == 0 && backup[ny][nx] == 0) {

				visited[ny][nx] = 1;

				q.push(ny * 10 + nx);

			}

 

		}

	}//가스 확산 완료

 

	//가스구역 세기

	int candi = 0;

	for (int y = 0; y < n; ++y) {

		for (int x = 0; x < m; ++x) {

			if (backup[y][x] == 0) {//안전구역이면

				++candi;

			}

		}

	}

	if (ret < candi) {//전에있던 안전구역보다 현재 센 안전구역이 크다면 ret 대입

		ret = candi;

	}

}

	void pick_dfs(int count, int sy, int sx) {

		if (count == 3) {

			bfs();

			return;

		}

		for (int y = sy; y < n; ++y) {

			for (int x = sx; x < m; ++x) {//처음에는 0,0이지만 5,4에 벽을 세웠다면 다음에 추가되는 다리는 5,5부터 넣으면된다.

				if (map[y][x] == 0) {//벽을 설치하기 위해서는 빈공간이어야한다.

					map[y][x] = 1;//벽을 채우고

					pick_dfs(count + 1, y, x);//벽을 세우는거니까 +1해서 백트랙킹이 작용됨.

					map[y][x] = 0;//코드를 다시 0으로 넣어주면된다.하나씩 벽 세워보고 다시 빼는 작업,bfs 작업후 리턴 후 다음턴 실행

				}

			}

			sx = 0;

		}

	}

 

int main() { 

	freopen("sample_input.txt", "r", stdin); 

	scanf("%d %d", &n, &m);

for (int y = 0; y < n; ++y) { 

	for (int x = 0; x < m; ++x) { 

		scanf("%d", &map[y][x]); 

	} }

pick_dfs(0, 0, 0);

printf("%d\n", ret);

return 0; }
